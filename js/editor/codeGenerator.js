// Code Generator - Generates course.js file content
export class CodeGenerator {
    constructor(courseData) {
        this.courseData = courseData;
    }
    
    generate() {
        const data = this.courseData;
        const lines = [];
        
        // Header
        lines.push(`// ${data.name} - Generated by Course Editor`);
        lines.push(`import { TerrainType } from '../js/terrain.js';`);
        lines.push(`import { TreeType } from '../js/trees.js';`);
        lines.push('');
        
        // Export course object
        lines.push(`export const course = {`);
        lines.push(`    name: '${this.escapeString(data.name)}',`);
        lines.push(`    bounds: { minX: ${data.bounds.minX}, maxX: ${data.bounds.maxX}, minY: ${data.bounds.minY}, maxY: ${data.bounds.maxY} },`);
        lines.push('');
        
        // Elevation grid
        lines.push(`    elevationGrid: {`);
        lines.push(`        cols: ${data.elevationGrid.cols},`);
        lines.push(`        rows: ${data.elevationGrid.rows},`);
        lines.push(`        cellSize: ${data.elevationGrid.cellSize},`);
        lines.push(`        data: [`);
        
        data.elevationGrid.data.forEach((row, y) => {
            const rowStr = row.map(v => this.round(v)).join(', ');
            const comma = y === data.elevationGrid.data.length - 1 ? '' : ',';
            lines.push(`            [${rowStr}]${comma}`);
        });
        
        lines.push(`        ]`);
        lines.push(`    },`);
        lines.push('');
        
        // Terrain dictionaries - all terrain by type
        lines.push(`    // ========== TERRAIN ==========`);
        lines.push(`    terrain: {`);
        
        const terrainTypes = ['fairway', 'rough', 'bunker', 'water', 'green', 'teeBox', 'outOfBounds', 'path'];
        terrainTypes.forEach((type, typeIndex) => {
            const zones = data.terrain[type] || [];
            const isLastType = typeIndex === terrainTypes.length - 1;
            
            lines.push(`        ${type}: [`);
            zones.forEach((zone, zIndex) => {
                lines.push(this.generateZone(zone, zIndex === zones.length - 1));
            });
            lines.push(`        ]${isLastType ? '' : ','}`);
        });
        
        lines.push(`    },`);
        lines.push('');
        
        // Trees - global
        lines.push(`    // ========== TREES ==========`);
        lines.push(`    trees: [`);
        data.trees.forEach((tree, tIndex) => {
            const comma = tIndex === data.trees.length - 1 ? '' : ',';
            lines.push(`        { type: TreeType.${tree.type}, x: ${this.round(tree.x)}, y: ${this.round(tree.y)} }${comma}`);
        });
        lines.push(`    ],`);
        lines.push('');
        
        // Sprinkler heads - global
        lines.push(`    // ========== SPRINKLER HEADS ==========`);
        lines.push(`    sprinklerHeads: [`);
        const sprinklerHeads = data.sprinklerHeads || [];
        sprinklerHeads.forEach((sprinkler, sIndex) => {
            const comma = sIndex === sprinklerHeads.length - 1 ? '' : ',';
            lines.push(`        { x: ${this.round(sprinkler.x)}, y: ${this.round(sprinkler.y)} }${comma}`);
        });
        lines.push(`    ],`);
        lines.push('');
        
        // Hole details - just positioning info
        lines.push(`    // ========== HOLE DETAILS ==========`);
        lines.push(`    holes: [`);
        
        data.holes.forEach((hole, index) => {
            const yards = this.calculateHoleLength(hole);
            lines.push(`        {`);
            lines.push(`            number: ${hole.number},`);
            lines.push(`            name: '${this.escapeString(hole.name)}',`);
            lines.push(`            par: ${hole.par},`);
            lines.push(`            yards: ${yards},`);
            
            // Tee position
            if (hole.tee) {
                lines.push(`            tee: { x: ${this.round(hole.tee.x)}, y: ${this.round(hole.tee.y)} },`);
            } else {
                lines.push(`            tee: null,`);
            }
            
            // Hole position
            if (hole.hole) {
                lines.push(`            hole: { x: ${this.round(hole.hole.x)}, y: ${this.round(hole.hole.y)} },`);
            } else {
                lines.push(`            hole: null,`);
            }
            
            // Centreline
            lines.push(`            centreline: [`);
            if (hole.centreline && hole.centreline.length > 0) {
                const pointsPerLine = 4;
                for (let i = 0; i < hole.centreline.length; i += pointsPerLine) {
                    const chunk = hole.centreline.slice(i, i + pointsPerLine);
                    const pointStrs = chunk.map(p => `[${this.round(p[0])}, ${this.round(p[1])}]`);
                    const lineComma = i + pointsPerLine < hole.centreline.length ? ',' : '';
                    lines.push(`                ${pointStrs.join(', ')}${lineComma}`);
                }
            }
            lines.push(`            ]`);
            
            const holeComma = index === data.holes.length - 1 ? '' : ',';
            lines.push(`        }${holeComma}`);
        });
        
        lines.push(`    ]`);
        lines.push(`};`);
        
        return lines.join('\n');
    }
    
    generateZone(zone, isLast) {
        const comma = isLast ? '' : ',';
        const lines = [];
        
        if (zone.shape === 'rect') {
            lines.push(`            { shape: 'rect', x: ${this.round(zone.x)}, y: ${this.round(zone.y)}, width: ${this.round(zone.width)}, height: ${this.round(zone.height)} }${comma}`);
        } else if (zone.shape === 'ellipse') {
            lines.push(`            { shape: 'ellipse', cx: ${this.round(zone.cx)}, cy: ${this.round(zone.cy)}, rx: ${this.round(zone.rx)}, ry: ${this.round(zone.ry)} }${comma}`);
        } else if (zone.shape === 'line') {
            lines.push(`            {`);
            lines.push(`                shape: 'line',`);
            lines.push(`                width: ${zone.width || 3},`);
            lines.push(`                points: [`);
            
            // Format points nicely
            const pointsPerLine = 4;
            for (let i = 0; i < zone.points.length; i += pointsPerLine) {
                const chunk = zone.points.slice(i, i + pointsPerLine);
                const pointStrs = chunk.map(p => `[${this.round(p[0])}, ${this.round(p[1])}]`);
                const lineComma = i + pointsPerLine < zone.points.length ? ',' : '';
                lines.push(`                    ${pointStrs.join(', ')}${lineComma}`);
            }
            
            lines.push(`                ]`);
            lines.push(`            }${comma}`);
        } else if (zone.shape === 'polygon') {
            lines.push(`            {`);
            lines.push(`                shape: 'polygon',`);
            lines.push(`                points: [`);
            
            // Format points nicely
            const pointsPerLine = 4;
            for (let i = 0; i < zone.points.length; i += pointsPerLine) {
                const chunk = zone.points.slice(i, i + pointsPerLine);
                const pointStrs = chunk.map(p => `[${this.round(p[0])}, ${this.round(p[1])}]`);
                const lineComma = i + pointsPerLine < zone.points.length ? ',' : '';
                lines.push(`                    ${pointStrs.join(', ')}${lineComma}`);
            }
            
            lines.push(`                ]`);
            lines.push(`            }${comma}`);
        }
        
        return lines.join('\n');
    }
    
    round(num) {
        return Math.round(num * 10) / 10;
    }
    
    escapeString(str) {
        return str.replace(/'/g, "\\'").replace(/\n/g, '\\n');
    }
    
    calculateHoleLength(hole) {
        const WORLD_TO_YARDS = 4;
        
        // If centreline exists, use it
        if (hole.centreline && hole.centreline.length >= 2) {
            let totalDist = 0;
            for (let i = 1; i < hole.centreline.length; i++) {
                const p1 = hole.centreline[i - 1];
                const p2 = hole.centreline[i];
                const dx = p2[0] - p1[0];
                const dy = p2[1] - p1[1];
                totalDist += Math.sqrt(dx * dx + dy * dy);
            }
            return Math.round(totalDist * WORLD_TO_YARDS);
        }
        
        // Fallback: straight line from tee to hole
        if (hole.tee && hole.hole) {
            const dx = hole.hole.x - hole.tee.x;
            const dy = hole.hole.y - hole.tee.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return Math.round(dist * WORLD_TO_YARDS);
        }
        
        return 0;
    }
}
